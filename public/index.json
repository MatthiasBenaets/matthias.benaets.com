[{"content":"","date":"28 September 2022","permalink":"/tags/docker/","section":"Tags","summary":"","title":"Docker"},{"content":"","date":"28 September 2022","permalink":"/tags/homelab/","section":"Tags","summary":"","title":"Homelab"},{"content":" ","date":"28 September 2022","permalink":"/posts/homelab/","section":"Posts","summary":" ","title":"Homelabbing"},{"content":"\nWelcome üëã, I\u0026rsquo;m Matthias\nI\u0026rsquo;m currenlty employed at University Hasselt as an ICT officer. My main goal is to improve courses and lectures didactially and technologically for the master of mathematics/statistics program. I love tech and like to explore and learn about various open-source technologies and projects. This website will mainly be use to track my career, experience and as a personal knowledge base. Learn more about me , or send me an email to get in touch. ","date":"28 September 2022","permalink":"/","section":"Matthias Benaets","summary":"","title":"Matthias Benaets"},{"content":" My thoughts, ideas, experiences and guides about the things I find interesting. ","date":"28 September 2022","permalink":"/posts/","section":"Posts","summary":"My thoughts, ideas, experiences and guides about the things I find interesting.","title":"Posts"},{"content":"","date":"28 September 2022","permalink":"/tags/proxmox/","section":"Tags","summary":"","title":"Proxmox"},{"content":"","date":"28 September 2022","permalink":"/tags/","section":"Tags","summary":"","title":"Tags"},{"content":"","date":"28 September 2022","permalink":"/tags/truenas/","section":"Tags","summary":"","title":"TrueNAS"},{"content":" Introduction # NixOS is a Linux distribution based on the Nix package manager. The main reason for using NixOS is the declarative reproducibility of your system.\nNixOS allows you to declare pretty much everything about your system inside a single document. This document allows for the reproducable setup that can be used on any system.\nWhenever this document gets updates, NixOS will generate a new generation which can be booted into. Since NixOS is known for being unbreakable, it will also store the previous generations just in case the new changes are causing issues.\nUnlike the average Linux destribution, NixOS stores all it\u0026rsquo;s packages inside the /nix/store. Directory /lib, /usr/lib, /bin and /usr/bin are pretty much non-existant.\nIn this guide I would go into to much detail about setting up the installatia media but by following the steps below, you\u0026rsquo;ll end up with a decent understanding on how to configure your own declarative reproducible NixOS setup. I highly recommend that you use these notes in conjunction with the mini-course video to learn more about NixOS.\nGetting Started # Download the iso and burn it to a bootable device . Boot into device with iso. Either follow the Calamares Installer or the step below:\nPartitioning\nOpen the terminal and switch to the root user su Run the commands below: This will format the disk and create the partitions Change 8GiB swap to your personal preference. Or remove it and end the root partition at 100%. Choose between the two options between \u0026ldquo;\u0026lt; \u0026gt;\u0026rdquo;. Left option is legacy boot, right option is UEFI. Change /dev/sda to the disk used to install NixOS. # parted /dev/sda -- mklabel \u0026lt;msdos/gpt\u0026gt; # parted /dev/sda -- mkpart primary \u0026lt;1MiB -8GiB/512MiB -8GiB\u0026gt; # parted /dev/sda -- mkpart primary linux-swap -8GiB 100% /* extra for UEFI */ # parted /dev/sda -- mkpart ESP fat32 1Mib 512MiB # parted /dev/sda -- set 3 esp on # mkfs.ext4 -L nixos /dev/sda1 # mkswap -L swap /dev/sda2 /* extra for UEFI */ # mkfs.fat -F 32 -n boot /dev/sda3 Mounting\n# mount /dev/disk/by-label/nixos /mnt /* extra for UEFI */ # mkdir -p /mnt/boot # mount /dev/disk/by-label/boot /mnt/boot # swapon /dev/sda2 Initial Configuration # Generate a default configuration: # nixos-generate-config --root /mnt Location of configuration.nix: # cd /mnt/etc/nixos Configuration.nix # General\nArgument on how to evaluate config: {config, pkgs, ...}: Pull in other files used within the config: import = [./hardware-configuration.nix]; Boot\nLegacy\nOnly viable if dualbooting linux distributions* # Default Grub setup boot.loader.grub.enable = true; boot.loader.grub.version = 2; boot.loader.grub.device = \u0026#34;/dev/vda\u0026#34;; # Dual booting made easy (Optional) boot.loader.grub.useOSProber = true; # Dual booting made a bit harder (Extra Optional) boot.loader.grub.extraEntries = \u0026#39;\u0026#39; menuentry \u0026#34;Windows 10\u0026#34; { chainloader (hd0,1)+1 } \u0026#39;\u0026#39;; UEFI\nUsed for larger boot drives and dual booting with Windows* # Default UEFI setup boot.loader.systemd-boot.enable = true; boot.loader.efi.canTouchEfiVariables = true; # Dual Booting using grub boot.loader = { efi = { canTouchEfiVariables = true; efiSysMountPoint = \u0026#34;/boot/efi\u0026#34;; # /boot will probably work too }; grub = { # Using grub means first 2 lines can be removed enable = true; #device = [\u0026#34;nodev\u0026#34;]; # Generate boot menu but not actually installed devices = [\u0026#34;nodev\u0026#34;]; # Install grub efiSupport = true; useOSProber = true; # Or use extraEntries like seen with Legacy }; # OSProber will probably not find windows partition on first install }; Extras\nSome extra useful boot parameters { pkgs, ... }: { boot ={ kernelPackages = pkgs.linuxPackages_latest; # Get latest kernel initrd.kernelModules = [\u0026#34;amdgpu\u0026#34;]; # More on this later on (setting it for xserver) loader = { grub = { configurationLimit = 5; # Limit stored system configurations. }; # Also exists for systemd-boot timeout = 5; # Work for grub and efi boot, time before auto-boot }; }; } Internationalisation\nLocales, Layouts and Options # Clock time.timeZone = \u0026#34;Belgium/Brussels\u0026#34;; # Locale i18n.defaultLocale = \u0026#34;en_US.UTF-8\u0026#34;; i18n.extraLocaleSettings = { LC_TIME = \u0026#34;nl_BE.UTF-8\u0026#34;; LC_MONETARY = \u0026#34;nl_BE.UTF-8\u0026#34;; }; # TTY layout console = { font = \u0026#34;...\u0026#34;; keyMap = \u0026#34;...\u0026#34;; # us / fr / azerty / etc... }; # XServer layout (possibly also sets console now) services.xserver.layout = \u0026#34;...\u0026#34; # us / fr / be / etc.. # Extra keyboard settings: services.xserver.xkbOptions = \u0026#34;eurosign:e\u0026#34;; # For example adds ‚Ç¨ DE/WM\nDefault services.xserver.enable = true; services.xserver.displayManager.sddm.enable = true; services.xserver.desktopManager.plasma5.enable = true; Customized services = { xserver = { enable = true; displayManager = { lightdm.enable = true; defaultSession = ‚Äúnone+bspwm‚Äù; }; desktopManager.xfce.enable = true; windowManager.bspwm.enable = true; }; }; Hardware\nExample for sound and bluetooth sound = { enable = true; mediaKeys.enable = true; }; services = { pipewire = { enable = true; alsa = { enable = true; support32Bit = true; }; pulse.enable = true; }; }; hardware = { bluetooth = { enable = true; hsphfpd.enable = true; # HSP \u0026amp; HFP daemon settings = { General = { Enable = \u0026#34;Source,Sink,Media,Socket\u0026#34;; }; }; }; }; Example of libinput for touchpads services.xserver.libinput = { enable = true; #tapping = true; #naturalScrolling = true; #... Users\nExample on how to create a user and add them to groups. users.users.\u0026lt;name\u0026gt; = { isNormalUser = true; extraGroups = [ \u0026#34;wheel\u0026#34; \u0026#34;video\u0026#34; \u0026#34;audio\u0026#34; \u0026#34;networkmanager\u0026#34; \u0026#34;lp\u0026#34; \u0026#34;scanner\u0026#34;] #initialPassword = \u0026#34;password\u0026#34;; #shell = pkgs.zsh; }; Packages\nExample of how to declare packages environment.systemPackages = with pkgs; [ vim wget git #pkgs.firefox firefox StateVersion\nNo need to touch this. Nothing to do with the version of the system. Just tells the version of state/config Can be updated to a stable version if you are really sure. Hardware-configuration.nix # Generate\nAlso get automatically generated with: # nixos-generate-config --root /mnt Should detect mounted drives, device parts, kernelModules, etc.. that are needed Can be deleted and regenerated with: # nixos-generate-config File System\n$ sudo blkid or just look in gparted fileSystems.\u0026#34;/\u0026#34; = { device = \u0026#34;/dev/disk/by-uuid/e97ad9a8-d84f-4710-b8c9-cfa7707510ca\u0026#34;; fsType = \u0026#34;ext4\u0026#34;; }; #fileSystem.\u0026#34;/\u0026#34; = # { device = \u0026#34;/dev/disk/by-label/nixos\u0026#34;; # fsType = \u0026#34;ext4\u0026#34;; # }; Networking\nNetwork card details Deprecated but keep: networking.useDHCP = false; Just internet via ethernet: networking.interfaces.\u0026lt;networkcard-id\u0026gt;.useDHCP = true; networking = { #hostName = \u0026#34;nixos\u0026#34;; #networkmanager.enable = true; interfaces ={ enp0s3 = { #useDHCP = true; ipv4.addresses = [ { # Ofcourse not compatible with networkmanager address = \u0026#34;192.168.0.50\u0026#34;; prefixLength = 24; } ]; }; }; defaultGateway = \u0026#34;192.168.0.1\u0026#34;; nameservers = [ \u0026#34;1.1.1.1\u0026#34; ]; }; Installation # For the initial installation: # nixos-install After applying changes to your configuration.nix: # nixos-rebuild switch At the end of the installation process, pick a root password. Reboot If users.users.\u0026lt;user\u0026gt;.initialPassword was not set, you will need to do this now via the TTY Ctr + Alt + F\u0026lt;1-12\u0026gt; -\u0026gt; Log in with root # passwd \u0026lt;user\u0026gt; Ctrl + Alt + F1 or F7 -\u0026gt; Log into graphical environment with user Package Management # Nix packages and options can be found here: packages | options Install individually with Nix Package Manager $ nix-env -iA nixos.\u0026lt;package\u0026gt; $ nix-env --uninstall \u0026lt;package\u0026gt; Temporarily install packages using $ nix-shell -p \u0026lt;package\u0026gt; Declaring Packages\nInstall systemwide packages with configuration.nix environment = { systemPackages = with pkgs; [ plex superTux ]; }; nixpkgs.config.allowUnfree = true; Declaring Options\nSome packages will also have options to configure it further services = { plex = { enable = true; openFirewall = true; }; }; Declaring Options\nValues that can change often or you want to use multiple times let rofi-theme = { \u0026#34;*\u0026#34; = { bg = \u0026#34;#FFFFFF\u0026#34;; }; }; in { programs.rofi = { enable = true; theme = rofi-theme; }; } Declaring Options\nChange packages that already exist in nix nixpkgs.overlays = [ (self: super: { sl = super.sl.overrideAttrs (old: { src = super.fetchFromGitHub { owner = \u0026#34;mtoyoda\u0026#34;; repo = \u0026#34;sl\u0026#34;; rev = \u0026#34;923e7d7ebc5c1f009755bdeb789ac25658ccce03\u0026#34;; sha256 = \u0026#34;0000000000000000000000000000000000000000000000000000\u0026#34;; }; }); }) (self: super: { discord = super.discord.overrideAttrs ( _: { src = builtins.fetchTarball { url = \u0026#34;https://discord.com/api/download?platform=linux\u0026amp;format=tar.gz\u0026#34;; sha256 = \u0026#34;0000000000000000000000000000000000000000000000000000\u0026#34;; #52 0\u0026#39;s }; } ); }) ]; Applying\n$ sudo nixos-rebuild switch Extras # Update \u0026amp; Upgrade\n$ nix-channel --add https://nixos.org/channels/nixos-21.11 OR $ nix-channel --update Next rebuild,use the \u0026ndash;upgrade flag $ sudo nixos-rebuild --upgrade If Apps are installed through nix-env $ nix-env -u '*'\nGarbage Collections\nRemove undeclared packages, dependencies and symlinks: $ nix-collect-garbage Remove above of older generations: $ nix-collect-garbage --delete-old List generations: $ nix-env --list-generations Remove specific generations or older than \u0026hellip; days: $ nix-env --delete-generations 14d $ nix-env --delete-generations 10 11 Optimize store: $ nix-store --gc All in one:$ nix-collect-garbage -d Inside configurations.nix\nnix = { settings.auto-optimise-store = true; gc = { automatic = true; dates = \u0026#34;weekly\u0026#34;; options = \u0026#34;--delete-older-than 7d\u0026#34; }; }; Home-Manager # Home-Manager is configuration.nix but for the user environment. Instead of installing packages system-wide, it will install packages only for a specified user. It has plenty more options to declare if your configuration.nix and it\u0026rsquo;s a great way to configure and manage your ~/.config dotfiles. All configurations options can be found in the Home-Manager Appendixes .\nHome-Manager can be set up in multiple way. Below you will find some of the option on how to implement it in your configuration.\nBefore getting started with Home-Manager, a nix-channel will need to be created so the system can make use of the new configuration options. If you plan on using Home-Manager as a NixOS-module, run the commands below as root.\nUnstable channel: $ nix-channel --add https://github.com/nix-community/home-manager/archive/master.tar.gz home-manager Stable channel: nix-channel --add https://github.com/nix-community/home-manager/archive/release-\u0026lt;version.number\u0026gt;.tar.gz home-manager And update the channels with: $ nix-channel --update\nStandalone # Installation is done by running the command: $ nix-shell '\u0026lt;home-manager\u0026gt;' -A install You can nog edit the home.nix file in ~/.config/nixpkgs/home.nix\nModule # Implement the options below into your configuration.nix. You can afterwards nixos-rebuild switch.\nlet in { imports = [ \u0026lt;home-manager/nixos\u0026gt; ]; users.users.\u0026lt;name\u0026gt; = { isNormalUser = true; } home-manager.users.\u0026lt;name\u0026gt; = { pkgs, ‚Ä¶}: { # declared packages. for example: home.packages = [ pkgs.atool pkgs.httpie ]; }; } Configuration # Declaring packages\nhome.packages = with pkgs; [ firefox ]; services.dunst = { enable = true; }; To apply the changes to the standalone version: $ home-manager switch\nDotfiles\nImplement existing config inside the nix file home.file = { \u0026#34;.config/alacritty/alacritty.yml\u0026#34;.text = \u0026#39;\u0026#39; {\u0026#34;font\u0026#34;:{\u0026#34;bold\u0026#34;:{\u0026#34;style\u0026#34;:\u0026#34;Bold\u0026#34;}}} \u0026#39;\u0026#39;; }; Implement with files saved locally home.file.\u0026#34;.doom.d\u0026#34; = { source = ./doom.d; recursive = true; onChange = builtins.readFile ./doom.sh; }; home.file.\u0026#34;.config/polybar/script/mic.sh\u0026#34;={ source = ./mic.sh; executable = true; }; Declarativly with existing options,\\ { xsession = { windowManager = { bspwm = { enable = true; rules = { \u0026#34;Emacs\u0026#34; = { desktop = \u0026#34;3\u0026#34;; follow = true; state = \u0026#34;tiled\u0026#34;; }; \u0026#34;.blueman-manager-wrapped\u0026#34; ={ state = \u0026#34;floating\u0026#34;; sticky = true; }; }; }; }; }; } Flakes # Flakes are a fully supported feature of the NixOS. With flakes you can specify code dependencies declaratively. These will be stored inside a flake.lock file. An example of a code dependency is home-manager. Flakes make rebuilding and updating the whole system a lot easier. Arguably it makes it way easier to build your own config. You can save multiple configs inside one file and share them easily with others using something like GitHub.\nIt\u0026rsquo;s highly recommended that you have a look at the wiki article about flakes.\nSetup # Inside the configuration.nix add:\nnix = { package = pkgs.nixFlakes; extraOptions = \u0026#34;experimental-features = nix-command flakes\u0026#34;; }; Now choose a location where you want to store the flake file and run:\n$ nix flake init Inside the flake.nix file you will find the options inputs and outputs. The inputs are used to declare your dependencies. Of of these dependencies is, for example, the nix packages itself. inputs = { nixpkgs.url = \u0026#34;github:nixos/nixpkgs/nixos-unstable\u0026#34;; }; The outpus are the arguments that can be used that reference the imputs. This can be:\nEverything you imported Packages / configurations / modules / options / etc \u0026hellip; Configuration # An example of a basic flake.nix file is:\ninputs = { nixpkgs.url = \u0026#34;github:nixos/nixpkgs/nixos-unstable\u0026#34;; #nixpkgs-unstable.url = \u0026#34;github:nixos/nixpkgs/nixpkgs-unstable\u0026#34;; }; outputs = { nixpkgs, home-manager, ‚Ä¶ }: let system = ‚Äúx86_64-linux‚Äù; pkgs = import nixpkgs { inherit system; config.allowUnfree = true; }; lib = nixpkgs.lib; in { nixosConfigurations = { \u0026lt;user\u0026gt; = lib.nixosSystem { inherit system; modules = [ ./configuration.nix ]; }; #\u0026lt;second user\u0026gt; = lib.nixosSystem { #inherit system; #modules = [ ./configuration.nix ]; #}; }; } In this example the configuration.nix and hardware-configuration.nix file is move to the same directory as the flake.nix file. To update the system using the flake.nix file run: $ sudo nixos-rebuild switch --flake .#\nHome-Manager # Once again, Home-Manager can be set up in multiple ways inside the flake.\nSeperate\n{ inputs = { #other inputs home-manager = { url = github:nix-community/home-manager; inputs.nixpkgs.follows = \u0026#34;nixpkgs\u0026#34;; }; }; outputs = { self, nixpkgs, home-manager, ... }: let #variables in { #other outputs hmConfig = { \u0026lt;user\u0026gt; = home-manager.lib.homeManagerConfiguration { inherit system pkgs; username = ‚Äú\u0026lt;user\u0026gt;‚Äù; homeDirectory = ‚Äú/home/\u0026lt;user\u0026gt;‚Äù; #stateVersion = \u0026#34;22.05\u0026#34;; # If there is any complaining about differing stateVersions, specifically state here. configuration = { imports = [ /home/\u0026lt;user\u0026gt;/.config/home/home.nix ]; }; }; }; }; } Inside nixosConfigurations\n{ inputs = { #other inputs home-manager = { url = github:nix-community/home-manager; inputs.nixpkgs.follows = \u0026#34;nixpkgs\u0026#34;; }; }; outputs = { self, nixpkgs, home-manager, ... }: let #variables in { nixosConfigurations = { \u0026lt;user\u0026gt; = lib.nixosSystem { inherit system; modules = [ ./configuration.nix home-manager.nixosModules.home-manager { home-manager.useGlobalPkgs = true; home-manager.useUserPackages = true; home-manager.users.\u0026lt;user\u0026gt; = { imports = [ ./home.nix ]; }; } ]; }; }; }; } Build\nIf you chose for the seperate options, you will have to rebuild your system once for home-manager and once for flake itself. You will first need to build your home-manager config and afterwards switch.\n$ nix build .#hmConfig.\u0026lt;user\u0026gt;.activationPackage $ ./result/activate These command only need to be run on your initial installation. From now on you can switch to the new home-manager configuration using: home-manager switch --flake .#\u0026lt;host\u0026gt; If you chose for the nixosConfigurations module just rebuild as usual: $ sudo nixos-rebuild switch --flake .#\u0026lt;host\u0026gt;\nUpdate Since all dependencies are now declared, you will first need to update the flake.lock file before you can rebuild the system.\n$ nix flake update $ sudo nixos-rebuild switch --flake .#\u0026lt;host\u0026gt; Conclusion # By now, you should have a decent grasp of how NixOS works. If some notes are not clear, I highly recommend that you watch the 3 hour mini-course where I go into much more detail.\n","date":"12 April 2022","permalink":"/posts/nixos/","section":"Posts","summary":"Introduction # NixOS is a Linux distribution based on the Nix package manager.","title":"Getting Started with NixOS"},{"content":"","date":"12 April 2022","permalink":"/tags/nixos/","section":"Tags","summary":"","title":"NixOS"},{"content":" My name is Matthias Benaets, I currently reside in Alken, Limburg, Belgium .\nI\u0026rsquo;m a certified Secondary Education Teacher specialised in IT/Computer Science, the English language and ICT Coordination. Currently I work as ICT Officer at University Hasselt .\nI\u0026rsquo;m an avid cyclist, love the outdoors and enjoy wildlife photography. You can follow my adventure on Strava and view some of my images on Flickr .\nAt home I like to tinker with my homelab, self-hosting, open-source projects and containerisation.\nIf I have to describe myself in a couple words: enthusiastic ‚Ä¢ teamplayer ‚Ä¢ independent ‚Ä¢ pragmatic ‚Ä¢ deliberate ‚Ä¢ creative ‚Ä¢ meticulous ‚Ä¢ positive\nExperience # 2020-present # ICT Officer - Masters of Statistics\n@ University Hasselt Diepenbeek\n2020-2021 # Associate Professor - ICT Basics (101 \u0026amp; 201) - PXL Education\n@ PXL University College Hasselt\n2019-2020 # Technical Advisor - Telenet for Business\n@ Callexcell Sint-Truiden\n2017-2018 # Maintenance worker \u0026amp; Production operator\n@ Jiffy Packaging Wellen\nSkills # A lot of my experience is predominantly around teaching and didactical IT. Though, below is a list of tools and technologies that I have experience with:\nOffice # Microsoft Office Suite ‚Ä¢ Google Workspace\nAdobe CC # Photoshop ‚Ä¢ Illustrator ‚Ä¢ Lightroom (Classic) ‚Ä¢ Premiere Pro ‚Ä¢ After Effects\nProgramming / Scripting # VB.net ‚Ä¢ C# ‚Ä¢ Python ‚Ä¢ HTML5/CSS/JS ‚Ä¢ Shell Scripting\nOperating Systems # Windows ‚Ä¢ MacOS ‚Ä¢ GNU/Linux (Debian, Ubuntu, Arch, NixOS) ‚Ä¢ Proxmox VE ‚Ä¢ TrueNAS\nLanguages # Native/Fluent: Dutch ‚Ä¢ English Basic/Understand: French ‚Ä¢ German\nOthers # Salesforce ‚Ä¢ Containerization (Docker/LXC) ‚Ä¢ ZFS ‚Ä¢ Git\nEducation # 2016-2019 # Bachelor Teacher Secondary Education: English - Applied Informatics - ICT Coordinator\nwith honors @ PXL University College Hasselt\n2015-2016 # Bachelor Applied Informatics: CCNA Networking Essentials Certified\n@ PXL University College Hasselt\n2009-2015 # Secondary Education: Economics and Modern Languages\n@ Virga Jesse College Hasselt\n","date":"1 January 0001","permalink":"/about/","section":"Matthias Benaets","summary":"My name is Matthias Benaets, I currently reside in Alken, Limburg, Belgium .","title":"About Me"}]